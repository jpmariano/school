import NextAuth from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import {getUserInfo, isFetchResponse, userLogin} from '@/api/drupal';
import { CustomJWT, CustomSession, ErrorResponse, tokenResponse, userinfo } from "@/types";

export default NextAuth({
  providers: [
    CredentialsProvider({
      name: 'Credentials',

      credentials: {
        username: { label: 'Username', type: 'text' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials, req) {
        if (credentials) {
          const tokens: Response | ErrorResponse = await userLogin(credentials);
          if (isFetchResponse(tokens)) {
            if (tokens.ok) {
              const userInfoResponse: Response | ErrorResponse = await getUserInfo();
              if (isFetchResponse(userInfoResponse)) { 
                
                if (userInfoResponse.ok) {
         
                  const userInfo:userinfo =  await userInfoResponse.json();
               
                  if('sub' in userInfo){
                    return {
                      id: userInfo.sub, // This should be a unique identifier for the user
                      name: userInfo.name || null,
                      email: userInfo.email || null,
                      roles: userInfo.roles
                      // Include other fields if necessary
                    };
                  } else {
                    console.log('Error Response:', userInfoResponse);
                    return null;
                  } 
                } else {
                  console.log('Error Response:', userInfoResponse);
                  return null;
                }
                
              } else {
                console.log('Error Response:', userInfoResponse);
                return null;
              } 
              //console.log('Fetch Response:', await tokens.json());
            } else {
              return null;
              console.error('Fetch Error:', tokens);
            }
            
          } else {
            console.log('Error Response:', tokens);
            return null;
          }
          
        } else {
          console.log('no credentials');
          return null;
        }
      
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user, account }) {
      if(account && user){
      
        // the user present here gets the same data as received from DB call  made above -> fetchUserInfo(credentials.opt)
        return { ...token,
          access_token: account.access_token,
          refresh_token: account.refresh_token,
          expires_at: account.expires_at,
          scope: account.scope,
          userId: account.userId
        }
      }
      // Return previous token if the user is not signing in again
      return token as CustomJWT;
    },
    async session({ session, token, user }) {
      const customSession = session as CustomSession;
      customSession.access_token = (token as CustomJWT).access_token;
      customSession.refresh_token = (token as CustomJWT).refresh_token;
      customSession.expires_at = (token as CustomJWT).expires_at;
      customSession.scope = (token as CustomJWT).scope;
      customSession.userId = (token as CustomJWT).userId;
      return customSession;
    },
  },
  pages: {
    signIn: '/login',
    signOut: '/login',
    newUser: '/signup',
  },
  debug: process.env.NODE_ENV === 'development',
  session: {
    // Set to jwt in order to CredentialsProvider works properly
    strategy: 'jwt',
  },
  secret: process.env.SECRET, // TODO: Define env variables https://next-auth.js.org/configuration/options
  /*
  session: {
    strategy: "database",
    // Seconds - How long until an idle session expires and is no longer valid.
    maxAge: 30 * 24 * 60 * 60, // 30 days

    // Seconds - Throttle how frequently to write to database to extend a session.
    // Use it to limit write operations. Set to 0 to always update the database.
    // Note: This option is ignored if using JSON Web Tokens
    updateAge: 24 * 60 * 60, // 24 hours
    
    // The session token is usually either a random UUID or string, however if you
    // need a more customized session token string, you can define your own generate function.
    generateSessionToken: () => {
      return userData.id ?? randomBytes(32).toString("hex")
    }
  }*/
});
